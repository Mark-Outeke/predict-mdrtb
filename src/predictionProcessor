import React, { useEffect } from 'react';
import * as tf from '@tensorflow/tfjs';

const PredictionComponent = ({ jsonData }) => {
  useEffect(() => {
    const runPrediction = async () => {
      // Step 1: Extract data elements
      const extractDataElements = (data) => {
        let extractedData = [];

        data.forEach(instance => {
          instance.events.forEach(event => {
            let dataObject = {};
            event.dataValues.forEach(dataValue => {
              dataObject[dataValue.dataElement] = dataValue.value;
            });
            extractedData.push(dataObject);
          });
        });

        return extractedData;
      };

      const processedData = extractDataElements(jsonData);

      // Step 2: Process the data
      const categoricalColumns = ['CxdzmL6vtnx', 'FZMwpP1ncnZ', 'Aw9p1CCIkqL']; // Replace with actual IDs
      const numericColumns = ['dfNv7RZKIml', 'DDzcOBJwRnC']; // Replace with actual IDs

      // Label encode
      const labelEncode = (data, categoricalColumns) => {
        const labelEncoders = {};

        categoricalColumns.forEach(col => {
          labelEncoders[col] = {};
          let label = 0;
          data.forEach(row => {
            const value = row[col];
            if (!(value in labelEncoders[col])) {
              labelEncoders[col][value] = label++;
            }
            row[col] = labelEncoders[col][value];
          });
        });

        return { data, labelEncoders };
      };

      const { data: labelEncodedData, labelEncoders } = labelEncode(processedData, categoricalColumns);

      // Normalize numeric data
      const normalizeData = (data, numericColumns) => {
        const stats = {};

        numericColumns.forEach(col => {
          const values = data.map(row => parseFloat(row[col])).filter(val => !isNaN(val));
          const mean = values.reduce((a, b) => a + b, 0) / values.length;
          const std = Math.sqrt(values.map(val => Math.pow(val - mean, 2)).reduce((a, b) => a + b, 0) / values.length);

          stats[col] = { mean, std };

          data.forEach(row => {
            let val = parseFloat(row[col]);
            val = isNaN(val) ? 0 : (val - mean) / std;
            row[col] = val;
          });
        });

        return { data, stats };
      };

      const { data: normalizedData, stats } = normalizeData(labelEncodedData, numericColumns);

      // Handle missing values
      const handleMissingValues = (data) => {
        data.forEach(row => {
          Object.keys(row).forEach(key => {
            if (row[key] == null || isNaN(row[key])) {
              row[key] = 0;
            }
          });
        });

        return data;
      };

      const finalData = handleMissingValues(normalizedData);

      // Prepare input data
      const featureColumns = [...categoricalColumns, ...numericColumns];
      const inputData = finalData.map(row => {
        return featureColumns.map(col => row[col]);
      });

      // Step 3: Load the model
      const model = await tf.loadLayersModel('/tfjs_model/model.json');

      // Step 4: Make predictions
      const inputTensor = tf.tensor2d(inputData);
      const predictions = model.predict(inputTensor);
      const predictionValues = await predictions.array();

      console.log('Predictions:', predictionValues);

      // Process predictions as needed
    };

    runPrediction();
  }, [jsonData]);

  return (
    <div>
      <h1>Prediction Component</h1>
    </div>
  );
};

export default PredictionComponent;
